// Dear emacs, this is -*- c++ -*-
// $Id: SCycleBaseNTuple.icc,v 1.3.2.2 2009-01-08 16:09:32 krasznaa Exp $
/***************************************************************************
 * @Project: SFrame - ROOT-based analysis framework for ATLAS
 * @Package: Core
 *
 * @author Stefan Ask       <Stefan.Ask@cern.ch>           - Manchester
 * @author David Berge      <David.Berge@cern.ch>          - CERN
 * @author Johannes Haller  <Johannes.Haller@cern.ch>      - Hamburg
 * @author A. Krasznahorkay <Attila.Krasznahorkay@cern.ch> - CERN/Debrecen
 *
 ***************************************************************************/

#ifndef SFRAME_CORE_SCycleBaseNTuple_ICC
#define SFRAME_CORE_SCycleBaseNTuple_ICC

// System include(s):
#include <string.h>
#include <cxxabi.h>
#include <cstdlib>

// STL include(s):
#include <sstream>
#include <typeinfo>

// ROOT include(s):
#include <TTree.h>
#include <TBranch.h>


/**
 * This is a tricky function. To connect to "primitive" types in the input TTree
 * (ints, doubles, etc.) you have to define the variable itself, then give this
 * variable to the function. (The function takes a reference of the variable.)
 *
 * For STL objects (vectors, maps, you name it) you have to define a pointer to
 * such an object, and give this pointer to the function. You don't need to
 * initialise the pointer to anything, the function will take care about that.
 *
 * See the example cycles for some details.
 */
template< typename T >
void SCycleBaseNTuple::ConnectVariable( const char* treeName, const char* branchName,
                                        T& variable ) throw ( SError ) {

   // Access the TTree. The function will throw an exception if unsuccessful
   TTree* tree = GetInputTree( treeName );
   TBranch* br = 0;

   //
   // Detect what kind of variable we're dealing with:
   //
   const char* type_name = typeid( variable ).name();
   if( strlen( type_name ) == 1 ) {

      // For primitive types nothing fancy needs to be done
      m_logger << VERBOSE << "The supplied variable is a \"primitive\""
               << SLogger::endmsg;
      tree->SetBranchAddress( branchName, &variable, &br );

   } else {

      // The object pointers have to be initialised to zero before
      // connecting them to the branches
      m_logger << VERBOSE << "The supplied variable is an object pointer"
               << SLogger::endmsg;
      variable = 0;
      tree->SetBranchAddress( branchName, &variable, &br );

   }

   this->RegisterInputBranch( br );
   m_logger << DEBUG << "Connected branch \"" << branchName << "\" in tree \""
            << treeName << "\"" << SLogger::endmsg;

   return;

}

/**
 * Function putting an output variable in (one of) the output tree(s). The function
 * is quite complicated, but it is for the reason for making it very easy to use.
 * The user just has to give a reference to the output object, a name under which
 * it should appear in the output tree, and the tree name if multiple output trees
 * have been defined.
 *
 * The function detects the type of the user supplied variable, and puts it in the
 * output tree in a way depending on the object's type.
 *
 * Example:
 *
 * <code>
 *   Double_t m_var1;
 *   DeclareVariable( m_var1, "var1" );
 *   ...
 *   std::vector< int > m_var2;
 *   DeclareVariable( m_var2, "var2", "MyTree" );
 * </code>
 */
template < class T >
TBranch* SCycleBaseNTuple::DeclareVariable( T& obj, const char* name,
                                            const char* treeName ) throw( SError ) {

   TTree*   tree = 0;
   TBranch* branch = 0;

   //
   // Find the pointer to the output tree:
   //
   if( treeName ) {

      tree = GetOutputTree( treeName );

   } else {

      if( m_outputTrees.size() != 1 ) {
         SError error( SError::SkipInputData );
         error << "There can't be other than 1 output tree defined in order not to\n";
         error << "define a tree name in SCycleBaseNTuple::DeclareVariable(...)!";
         throw error;
      }

      tree = m_outputTrees.front();

   }

   //
   // Check if the tree has been found:
   //
   if( ! tree ) {
      SError error( SError::SkipInputData );
      if( treeName ) {
         error << "Couldn't find output tree with name: " << treeName;
      } else {
         error << "Couldn't find default output tree";
      }
      throw error;
   }

   m_logger << VERBOSE << "Found output tree with name: " << tree->GetName()
            << SLogger::endmsg;

   // Check if the branch exists already:
   branch = tree->GetBranch( name );
   if( ! branch ) {

      //
      // This branch doesn't exist yet. We have to (try to) create it.
      //
      m_logger << DEBUG << "Creating new output branch with name: " << name
               << SLogger::endmsg;

      // First of all, lets figure out what kind of object we're dealing with
      const char* type_name = typeid( obj ).name();

      if( strlen( type_name ) == 1 ) {

         //
         // This is a simple variable:
         //
         m_logger << VERBOSE << "The supplied variable is a \"primitive\""
                  << SLogger::endmsg;

         std::ostringstream leaflist;
         leaflist << name << "/" << RootType( type_name );
         branch = tree->Branch( name, &obj, leaflist.str().c_str() );

      } else {

         //
         // This is an object:
         //
         m_logger << VERBOSE << "The supplied variable is an object" << SLogger::endmsg;

         int status;
         char* real_type_name = abi::__cxa_demangle( type_name, 0, 0, &status );
         if( status ) {
            SError error( SError::StopExecution );
            error << "Couldn't demangle type name: " << type_name;
            throw error;
         }

         m_logger << VERBOSE << "Mangled name of object: " << type_name
                  << SLogger::endmsg;
         m_logger << VERBOSE << "De-mangled name of object: " << real_type_name
                  << SLogger::endmsg;

         //
         // Then try to add the object to the TTree. We have to do it in such a weird way,
         // since the "pointer" variable is going to disappear at the end of this function
         // so giving "&pointer" to TTree::Bronch would cause quite a crash when you're
         // writing out the event. (Trust me, I *know*... :-)) I'm storing the pointers
         // in an std::list, since lists don't move their elements around.
         // (vectors are allowed to do that. This one I've just read... :-))
         //
         T* pointer = &obj;
         m_outputVarPointers.push_back( pointer );
         branch = tree->Bronch( name, real_type_name, &m_outputVarPointers.back() );

         free( real_type_name );

      }

      if( ! branch ) {
         SError error( SError::SkipInputData );
         error << "Couldn't create branch with name: " << name;
         throw error;
      }

      m_logger << VERBOSE << "Successfully added branch" << SLogger::endmsg;

   } else {

      m_logger << WARNING << "A branch with the name \"" << name << "\" already exists"
               << SLogger::endmsg;
      m_logger << WARNING << "New object not added to tree!" << SLogger::endmsg;

   }

   return branch;

}

#endif // SFRAME_CORE_SCycleBaseNTuple_ICC
